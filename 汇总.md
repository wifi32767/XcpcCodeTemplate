## STL
### string
```c++
string s1 (5, 's'); //s1 = "sssss"
s1.size()
string s2 = "1234567890";
s2.insert(5, "bbb"); //s2 = "12345bbb67890"
string 3 = s4 = "1234567890";
s3.erase(5); //s3 = "12345"
s4.erase(5, 3); //s4 = "1234590"
string s5 = s2.substr(5); //s5 = "bbb67890"
string s6 = s2.substr(5, 3); //s6 = "bbb"
string s7 = "first second third";
string s8 = "second";
int index = s7.find(s8, 5); //第二个参数是开始查找的位置
//index = 6
index = s7.rfind(s8, 6); //最多查找到第二个参数
//index = 6
```
### set
```c++
// 相当于一个从小到大排序的序列，每次插入元素相当于会自动排序
set<int> s; // 元素不能重复的平衡树
multiset<int> s; // 元素能重复的平衡树
s.insert(3); // 插入一个元素，在set中，插入已有元素的操作会无效
s.erase(3); // 删除一个元素，在multiset中。会删除所有的该元素
set<int>::iterator it; // set的迭代器，相当于访问set中元素的指针
multiset<int>::iterator it; // multiset的迭代器
it = s.begin(); // 获取第一个元素（最小的元素）
it = s.end(); // 获取终止迭代器，位于最后一个元素之后
it = s.lower_bound(3), it = s.upper_bound(2); // 见二分查找
it ++; // 让it指向下一个元素
it --; // 让it指向上一个元素
if(s.find(3) != s.end()) // 判断元素是否存在
s.erase(s.find(3)); // 用于multiset中删除一个指定元素
s.erase(it ++); // 用于删除it并且让it指向下一个元素
a = *it; // 取值
for (set<int>::iterator it = s.begin(); it != s.end(); it ++) // 遍历
for (auto &i : s) // 遍历所有数值
```
### map
```c++
map<string,int> maps; //第一个是键的类型，第二个是值的类型
maps['c'] = 5; //通过下标进行访问
//map可以使用it->first来访问键，使用it->second访问值
for (auto it : mp) {
    cout << it.first << " " << it.second << endl;
}
// 定义一个map对象
map<int, string> m;
//用insert函数插入pair
m.insert(pair<int, string>(111, "kk"));
//用find函数查找元素
map<string,int> :: iterator it;
it = maps.find("123"); //返回的是迭代器
//迭代器h除
it = maps.find("123");
maps.erase(it);
//erase关键字删除
int n = maps.erase("123"); //如果删除了返回1，否则返回0
//用迭代器范围删除 : 把整个map清空
maps.erase(maps.begin(), maps.end());
```
### 二分查找
```c++
int *p = lower_bound(a + 1, a + n + 1, x); // 在a[1]到a[n]中找到大于等于x的第一个数的地址
int p = lower_bound(a + 1, a + n + 1, x) - a; // 获取下标
int *p = upper_bound(a + 1, a + n + 1, x); // 在a[1]到a[n]中找到大于x的第一个数的地址
int p = upper_bound(a + 1, a + n + 1, x) - a; // 获取下标
```
## 动态规划
### 区间dp
```c++
for (int len = 2; len <= n; len ++ ){
    for (int l = 1; l + len - 1 <= n; l ++ ){
        int r = l + len - 1;
        for (int k = l; k < r; k ++ ){
            dp[l][r] = max(dp[l][r], dp[l][k] + dp[k + 1][r] + arr[r] - arr[l - 1]);
        }
    }
}
```
### 状压dp
```c++
```
## 字符串
### 字符串哈希
```c++
ull hashe(string str){
    ull res = 0;
    int n = str.size();
    for (int i = 0; i < n; i ++ ){
        res *= 131;
        res += (int)str[i];
        res %= 202304192024; //随便一个大数
    }
    return res;
}
```
### KMP
```c++
while (i < b.size()){
    if (b[prelen] == b[i]) nex[i ++] = ++ prelen;
    else{
        if (prelen == 0) nex[i ++] = 0;
        else prelen = nex[prelen - 1];
    }
}
for (int i = 0; i < a.size(); i ++ ){
    while (j && a[i] != b[j]) j = nex[j - 1];
    if (a[i] == b[j]) j ++;
    if (j == b.size()) cout << i - j + 2 << endl, j = nex[j - 1];
}
```
## 数据结构
### ST表
ST表用于解决可重复贡献问题，不支持修改操作  
```c++
for(int i = 1; i <= n; i ++ ) scanf("%d", &st[i][0]);
for(int i = 1; i < 20; i ++ ){
    for(int j = 1; j + (1 << i) - 1 <= n; j ++ ){
        st[j][i] = max(st[j][i - 1], st[j + (1 << (i - 1))][i - 1]);
    }
}

int k = log2(r - l + 1);
printf("%d\n", max(st[l][k], st[r - (1 << k) + 1][k]));
```
### 树状数组
```c++
int input[MAX], tree[MAX];
//模板1，单点修改，区间求和
int lowbit(int k){
    return k & -k;
}
void init(){
    for (int i = 1; i <= n; i ++ ){
        tree[i] += input[i];
        int j = i + lowbit(i);
        if (j <= n) tree[j] += tree[i];
    }
}
int getsum(int k){
    int res = 0;
    while (k){
        res += tree[k];
        k -= lowbit(k);
    }
    return res;
}
void add(int ind, int k){
    while (ind <= n){
        tree[ind] += k;
        ind += lowbit(ind);
    }
}
int query(int left, int right){
    return getsum(right) - getsum(left - 1);
}
//模板2，单点查询，区间修改
int lowbit(int k){
    return k & -k;
}
//如果要使l到r之间的数据全加上k，那么build(l, k), build(b + 1, -k);
void build(int x, int y){
    for (int i = x; i <= n; i += lowbit(i))
        tree[i] += y;
}
void query(int x){
    ll ans = 0;
    for (int i = x; i >= 1; i -= lowbit(i))
        ans += tree[i];
    return ans + input[x];
}
```
### 线段树
```c++
ll input[MAX], tree[MAX * 4], tag[MAX * 4];
inline int ls(int x){return x << 1;} //左孩子
inline int rs(int x){return x << 1 | 1;} //右孩子
inline void push_up(int cur){ //向上更新区间和
    tree[cur] = tree[ls(cur)] + tree[rs(cur)];
}
void build(int l, int r, int cur){
    tag[cur] = 0;
    if (l == r){
        tree[cur] = input[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(l, mid, ls(cur)); //自顶向下建树
    build(mid + 1, r, rs(cur));
    push_up(cur);
}
inline void f(int l, int r, int cur, int val){
    tag[cur] += val; //区间得到lazy标记
    tree[cur] += val * (r - l + 1); //区间和加上区间长度乘以每个点增加的值
}
inline void push_down(int l, int r, int cur){
    int mid = (l + r) >> 1;
    f(l, mid, ls(cur), tag[cur]); //向下传标记
    f(mid + 1, r, rs(cur), tag[cur]);
    tag[cur] = 0; //标记传到下面去了
}
inline void update(int nl, int nr, int l, int r, int cur, int val){
    if (nl <= l && r <= nr){
        tree[cur] += val * (r - l + 1);
        tag[cur] += val;
        return;
    }
    push_down(l, r, cur);
    int mid = (l + r) >> 1;
    if (nl <= mid) update(nl, nr, l, mid, ls(cur), val); //向下更新
    if (nr > mid) update(nl, nr, mid + 1, r, rs(cur), val);
    push_up(cur);
}
ll query(int nl, int nr, int l, int r, int cur){
    ll ans = 0;
    if (nl <= l && r <= nr) return tree[cur];
    int mid = (l + r) >> 1;
    push_down(l, r, cur);
    if (nl <= mid) ans += query(nl, nr, l, mid, ls(cur));
    if (nr > mid) ans += query(nl, nr, mid + 1, r, rs(cur));
    return ans;
}
```
## 数学
### 欧拉筛
```c++
int primes[MAX], notPrime[MAX];
int cnt = 0;
for (int i = 2; i <= MAX; i ++ ){
    if (!notPrime[i]) primes[cnt ++] = i;
    for(int j = 0; primes[j] * i < MAX && j <= cnt; j ++ ){
        notPrime[primes[j] * i] = 1;
        if (i % primes[j] == 0) break;
    }
}
```
### gcd最大公约数
```c++
int gcd(int x, int y){
    return x ? y : gcd(y, y % x);
}
```
### power快速幂
```c++
ll power(ll x, int y){
    ll ans = 1;
    while (y){
        if (y & 1) ans *= x, ans %= mod;
        x *= x, x %= mod;
        y >>= 1;
    }
    return ans;
}
```
### 预处理阶乘及逆元求组合数
```c++
ll fac[MAX], inv[MAX];
void init(int n){
    fac[0] = 1;
    for (int i = 1; i <= n; i ++ ) fac[i] = fac[i - 1] * i % mod;
    inv[n] = power(fac[n], mod - 2);
    for (int i = n; i >= 1; i -- ) inv[i - 1] = inv[i] * i % mod;
}
ll C(int x, int y){
    if (y > x) return 0;
    return (fac[x] * inv[y] % mod) * inv[x - y] % mod;
}
```
### 分数取模
若求(a / b) % mod，设b的逆元为c，(a / b) % mod = (a * c) % mod  
其中c = b ** (mod - 2)
## 图论
### dijkstra
```c++
int n, m, s;
int ans[MAX];
bool vis[MAX];
vector<vector<pair<int, int>>> graph;
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> heap;
void dijkstra(void){
    heap.push({0, s});
    while(!heap.empty()){
        auto node = heap.top();
        heap.pop();
        int ind = node.second, dist = node.first;
        if (vis[ind]) continue;
        vis[ind] = 1;
        for (auto edge: graph[ind]){
            int to = edge.first, val = edge.second;
            if (ans[to] > ans[ind] + val){
                ans[to] = ans[ind] + val;
                heap.push({ans[to], to});
            }
        }
    }
}
```
## 杂项
### 快读快写
```c++
inline int read(){
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9'){
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}

void write(int x){
    if(x < 0)
        putchar('-'),x = -x;
    if(x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
    return;
}
```
### 离散化
```c++
int a[MAX]; // 原数组
int c[MAX], cnt = 0; // 用于离散化的数组，和离散化后最大值的大小
for (int i = 1; i <= n; i ++) c[++ cnt] = a[i];
sort(c + 1, c + cnt + 1);
cnt = unique(c + 1, c + cnt + 1) - c - 1; // 去重，可以跳过此步
for (int i = 1; i <= n; i ++ ) a[i] = lower_bound(c + 1, c + cnt + 1, a[i]) - c;
// c[a[i]] 即为 原始数组中下标为 i 位置的值
```